<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Coding Assignment</title>

    <style>
      body {
        font-family: sf pro text, -apple-system, BlinkMacSystemFont, Roboto,
          segoe ui, Helvetica, Arial, sans-serif, apple color emoji,
          segoe ui emoji, segoe ui symbol;
        font-weight: 400;
        line-height: 22.4px;
        font-size: 16px;
      }
      p, ul, ol {
        font-size: 16px;
        font-weight: 400;
      }
      h1, h2, h3, h4, h5, h6 {
        font-weight: bold;
      }
      ul {
        list-style: none;
        margin: 0;
        padding: 0;
        max-width: none;
      }
      .code-snippet {
        background-color: #fff;
        border: 1px solid #d1d7dc;
        color: #b4690e;
        font-size: 90%;
        padding: 0.2rem 0.4rem;
      }
      .code-block {
        background-color: #fff;
        color: #b4690e;
        font-size: 90%;
      }
      .black-block {
        color: #000000;
      }
      .italic-text {
        font-style: italic;
      }
    </style>
  </head>

  <body onload="main()">
    <h1 id="coding-title"></h1>
    <div>
      <h2>Instructions</h2>
      <div id="coding-instructions"></div>
    </div>
    <div>
      <h2>Test(s)</h2>
      <div id="coding-tests"></div>
    </div>
    <div>
      <h2>Solution(s)</h2>
      <div id="coding-solutions"></div>
    </div>

    <script>
      const quizData = {"title": "001 BST Convert Sorted Array to Balanced BST (  Interview Question)", "hasInstructions": true, "hasTests": true, "hasSolutions": true, "instructions": "<p><strong>Objective:</strong></p><p>The task is to develop a method that takes a sorted array of integers as input and constructs a height-balanced BST. <br><br>This involves creating a BST where the depth of the two subtrees of any node does not differ by more than one. <br><br>Achieving a height-balanced tree is crucial for optimizing the efficiency of tree operations, ensuring that the BST remains efficient for search, insertion, and deletion across all levels of the tree.</p><p><br></p><p><strong>Method Signature: </strong><code><strong>private Node sortedArrayToBST(int[] nums, int left, int right) </strong></code></p><p><br></p><p><strong>Method Overview:</strong> <code><strong>sortedArrayToBST</strong></code></p><ul><li><p><strong>Input:</strong> A sorted array of integers <code><strong>nums</strong></code>, provided in ascending order. The input array represents a sequential collection of elements to be transformed into a BST. The method also receives two additional parameters, <code><strong>left</strong></code> and <code><strong>right</strong></code>, which denotes the current segment of the array being processed.</p></li><li><p><strong>Process:</strong> The private method <code><strong>sortedArrayToBST</strong></code> employs a divide-and-conquer strategy to construct the BST. It identifies the middle element of the current array segment to serve as the subtree's root, ensuring that the resulting BST is height-balanced. The method recursively applies this logic to the left and right halves of the list, building up the BST from the bottom up.</p></li><li><p><strong>Output:</strong> The root node of a height-balanced BST constructed from the sorted array. This node links to all other nodes in the BST, effectively representing the entire tree structure.</p></li></ul><p><br></p><p><strong>Requirements:</strong></p><ul><li><p>The BST must maintain the binary search tree property: for any given node, all values in the left subtree must be less than the node's value, and all values in the right subtree must be greater.</p></li><li><p>The resulting BST should be height-balanced to optimize the efficiency of subsequent operations performed on the tree.</p></li></ul><p><br></p><p><strong>Implementation Details:</strong></p><ul><li><p>The class <code><strong>BinarySearchTree</strong></code> encapsulates the functionality needed to construct and manage a BST, including the public method <code><strong>sortedArrayToBST</strong></code> which serves as the public interface for converting a sorted array into a BST.</p></li><li><p>The private method <code><strong>sortedArrayToBST</strong></code> is a recursive helper function designed for internal use within the class. It directly supports the construction process by dividing the array and building the tree to ensure it is height-balanced.</p></li></ul><p><br></p><p>If you are having difficulty understanding the process of repeatedly breaking the array in half recursively, it might be helpful to you to watch the Merge Sort section and then come back to this exercise.</p><p><br></p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/coding_exercise_instructions/2024-02-06_18-44-21-aa0d278f463efddf113615300cf3e25d.png\"></p><p><br></p><p><br></p>", "tests": [{"file_name": "Evaluate.java", "content": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.BeforeEach;\n\nimport java.util.*;\n\n\npublic class Evaluate {      \n   \n    @BeforeEach\n    public void runMain() {\n        Main.main(new String[0]);\n    }\n\n    // Helper method to create BST from sorted array\n    private BinarySearchTree createBSTFromSortedArray(int[] nums) {\n        BinarySearchTree bst = new BinarySearchTree();\n        bst.sortedArrayToBST(nums);\n        return bst;\n    }\n\n    @Test\n    public void testEmptyArray() {\n        BinarySearchTree bst = createBSTFromSortedArray(new int[]{});\n        assertNull(bst.getRoot());\n        assertTrue(bst.isBalanced());\n    }\n\n    @Test\n    public void testSingleElement() {\n        BinarySearchTree bst = createBSTFromSortedArray(new int[]{10});\n        assertNotNull(bst.getRoot());\n        assertEquals(10, bst.getRoot().value);\n        assertNull(bst.getRoot().left);\n        assertNull(bst.getRoot().right);\n        assertTrue(bst.isBalanced());\n    }\n\n    @Test\n    public void testSmallOddNumberOfElements() {\n        BinarySearchTree bst = createBSTFromSortedArray(new int[]{1, 2, 3});\n        assertTrue(bst.isBalanced());\n        assertEquals(java.util.Arrays.asList(1, 2, 3), bst.inorderTraversal());\n    }\n\n    @Test\n    public void testSmallEvenNumberOfElements() {\n        BinarySearchTree bst = createBSTFromSortedArray(new int[]{1, 2, 3, 4});\n        assertTrue(bst.isBalanced());\n        assertEquals(java.util.Arrays.asList(1, 2, 3, 4), bst.inorderTraversal());\n    }\n\n    @Test\n    public void testLargeEvenNumberOfElements() {\n        BinarySearchTree bst = createBSTFromSortedArray(new int[]{1, 2, 3, 4, 5, 6});\n        assertTrue(bst.isBalanced());\n        assertEquals(java.util.Arrays.asList(1, 2, 3, 4, 5, 6), bst.inorderTraversal());\n    }\n\n    @Test\n    public void testLargeOddNumberOfElements() {\n        BinarySearchTree bst = createBSTFromSortedArray(new int[]{1, 2, 3, 4, 5, 6, 7});\n        assertTrue(bst.isBalanced());\n        assertEquals(java.util.Arrays.asList(1, 2, 3, 4, 5, 6, 7), bst.inorderTraversal());\n    }\n\n    @Test\n    public void testInorderTraversalMatchesSortedArray() {\n        int[] sortedArray = {1, 2, 3, 4, 5, 6, 7};\n        BinarySearchTree bst = createBSTFromSortedArray(sortedArray);\n        assertEquals(java.util.Arrays.asList(1, 2, 3, 4, 5, 6, 7), bst.inorderTraversal());\n    }\n    \n}\n\n\n"}], "solutions": [{"file_name": "BinarySearchTree.java", "content": "import java.util.ArrayList;\nimport java.util.List;\n\n\npublic class BinarySearchTree {\n\t\n    private Node root;\n\n    class Node {\n        public int value;\n        public Node left;\n        public Node right;\n\n        Node(int value) {\n            this.value = value;\n        }\n    }\n    \n    public Node getRoot() {\n        return root;\n    }\n    \n    public List<Integer> inorderTraversal() {\n        List<Integer> result = new ArrayList<>();\n        inorderHelper(this.root, result);\n        return result;\n    }\n\n    private void inorderHelper(Node node, List<Integer> result) {\n        if (node == null) return;\n        inorderHelper(node.left, result);\n        result.add(node.value);\n        inorderHelper(node.right, result);\n    }\n\n    public boolean isBalanced() {\n        return height(this.root) != -1;\n    }\n\n    private int height(Node node) {\n        if (node == null) return 0;\n        int leftHeight = height(node.left);\n        if (leftHeight == -1) return -1;\n        int rightHeight = height(node.right);\n        if (rightHeight == -1) return -1;\n        if (Math.abs(leftHeight - rightHeight) > 1) return -1;\n        return 1 + Math.max(leftHeight, rightHeight);\n    }\n    \n    public void sortedArrayToBST(int[] nums) {\n        this.root = sortedArrayToBST(nums, 0, nums.length - 1);\n    }\n    \n    private Node sortedArrayToBST(int[] nums, int left, int right) {\n        if (left > right) return null;\n        int mid = left + (right - left) / 2;\n        Node node = new Node(nums[mid]);\n        node.left = sortedArrayToBST(nums, left, mid - 1);\n        node.right = sortedArrayToBST(nums, mid + 1, right);\n        return node;\n    }\n    \n}\n\n\n"}, {"file_name": "Main.java", "content": "import java.util.Arrays;\nimport java.util.List;\n\npublic class Main {\n    \n    public static void main(String[] args) {\n        \n        // Test: Convert an empty array\n        System.out.println(\"\\n----- Test: Convert Empty Array -----\\n\");\n        checkBalancedAndCorrectTraversal(new int[]{}, Arrays.asList());\n\n        // Test: Convert an array with one element\n        System.out.println(\"\\n----- Test: Convert Single Element Array -----\\n\");\n        checkBalancedAndCorrectTraversal(new int[]{10}, Arrays.asList(10));\n\n        // Test: Convert a sorted array with odd number of elements\n        System.out.println(\"\\n----- Test: Convert Sorted Array with Odd Number of Elements -----\\n\");\n        checkBalancedAndCorrectTraversal(new int[]{1, 2, 3, 4, 5}, Arrays.asList(1, 2, 3, 4, 5));\n\n        // Test: Convert a sorted array with even number of elements\n        System.out.println(\"\\n----- Test: Convert Sorted Array with Even Number of Elements -----\\n\");\n        checkBalancedAndCorrectTraversal(new int[]{1, 2, 3, 4, 5, 6}, Arrays.asList(1, 2, 3, 4, 5, 6));\n\n        // Test: Convert a large sorted array\n        System.out.println(\"\\n----- Test: Convert Large Sorted Array -----\\n\");\n        checkBalancedAndCorrectTraversal(\n                Arrays.stream(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}).toArray(),\n                Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15));\n    }\n\n\n    private static void checkBalancedAndCorrectTraversal(int[] nums, List<Integer> expectedTraversal) {\n        BinarySearchTree bst = new BinarySearchTree();\n        bst.sortedArrayToBST(nums);\n        boolean isBalanced = bst.isBalanced();\n        List<Integer> inorder = bst.inorderTraversal();\n        System.out.println(\"Is balanced: \" + isBalanced);\n        System.out.println(\"Inorder traversal: \" + inorder);\n        System.out.println(\"Expected traversal: \" + expectedTraversal);\n        if (isBalanced && inorder.equals(expectedTraversal)) {\n            System.out.println(\"PASS: Tree is balanced and inorder traversal is correct.\\n\");\n        } else {\n            System.out.println(\"FAIL: Tree is either not balanced or inorder traversal is incorrect.\\n\");\n        }\n    }\n    \n}\n\n\n"}]};

      function renderCodeList(rootElement, codeList, className, titlePrefix) {
        for (var i = 0; i < codeList.length; i++) {
          var elem = codeList[i];
          var jsElem = document.createElement("div");
          jsElem.className = className;
          var jsElemTitle = document.createElement("h3");
          jsElemTitle.innerHTML = titlePrefix + " " + (i + 1);
          var jsElemBody = document.createElement("code");
          jsElemBody.className = "code-block black-block";
          jsElemBody.innerHTML = "<pre>" + elem.content + "</pre>";
          jsElem.appendChild(jsElemTitle);
          jsElem.appendChild(jsElemBody);
          rootElement.appendChild(jsElem);
        }
      }
      
      function main() {
        // display the assignment
        var codingTitle = document.getElementById("coding-title");
        codingTitle.innerHTML = quizData.title;
        
        var codingInstructions = document.getElementById("coding-instructions");
        if (quizData.hasInstructions) {
          codingInstructions.innerHTML = quizData.instructions;
        } else {
          codingInstructions.innerHTML = "<span class=\"italic-text\">" + quizData.instructions
            + "</span>";
        }

        // display the test(s)
        var codingTests = document.getElementById("coding-tests");
        if (!quizData.hasTests) {
          codingTests.innerHTML = "<span class=\"italic-text\">" + quizData.tests + "</span>";
        } else {
          renderCodeList(codingTests, quizData.tests, "coding-test", "Test");
        }
        

        // display the solution(s)
        var codingSolutions = document.getElementById("coding-solutions");
        if (!quizData.hasSolutions) {
          codingSolutions.innerHTML = "<span class=\"italic-text\">" + quizData.solutions + "</span>";
        } else {
          renderCodeList(codingSolutions, quizData.solutions, "coding-solution", "Solution");
        }
      }
    </script>
  </body>
</html>
